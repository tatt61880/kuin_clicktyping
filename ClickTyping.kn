{
	Clicktyping.kn (for Kuin 1.01):
		Last Modified: 2016/04/13 23:37:09.
		Created by @tatt61880
			https://twitter.com/tatt61880
			https://github.com/tatt61880
}

const FPS: int :: 60
const InputSpan: int :: @FPS / 5
const StrLenMax: int :: 40
const Savefile: []char :: "clicktyping.knd"

var seClick: @CSound
var seStart: @CSound
var seRestart: @CSound
var seNext: @CSound
var seCancel: @CSound

var se: []Snd@CSnd
const SoundEffectAvailable: bool :: false {oggファイルを用意できる場合は、trueにすることでSEを利用できます}

class CSound()
	{
	{メンバ変数にSnd@CSndがあるとコンパイルエラーになる不具合があるため、me.sndの代わりに、@seとme.idを使用します。}
	var snd: Snd@CSnd
	}
	var id: int
	func Init(sndFile_: []char): @CSound
		{
		do me.snd :: Snd@Load(sndFile_)
		}
		if(@SoundEffectAvailable)
			try
				do me.id :: @se.Len()
				do @se :~ [Snd@Load(sndFile_)]
			catch()
			end try
		end if
		return me
	end func
	func Play()
		{
		do me.snd.Play(0.0, false, 0.0)
		}
		if(@SoundEffectAvailable)
			try
				do @se[me.id].Play(0.0, false, 0.0)
			catch()
			end try
		end if
	end func
end class
func InitSoundEffects()
	do @se :: #[0]Snd@CSnd
	do @seClick		:: (#@CSound).Init("button48.ogg")
	do @seStart		:: (#@CSound).Init("button34.ogg")
	do @seRestart	:: (#@CSound).Init("button34.ogg")
	do @seNext		:: (#@CSound).Init("button34.ogg")
	do @seCancel	:: (#@CSound).Init("button39.ogg")
end func

const Hello: []char :: "Hello"
const World: []char :: "World!!"

func Init(cfg:Kuin@CCfg)
	do cfg.Title :: "ClickTyping \"" ~ @Hello ~ " " ~ @World ~ "!!\""
end func

var InsertMode:bool
var InputFlag:bool
var ColEnd: int

func UnShiftStr(col: &int, str: []char)
	if(!@InsertMode)
		if(col > @ColEnd)
			do col :$ @ColEnd
		end if
		for(1, @ColEnd - col)
			do @Del(col, str)
		end for
		do @InsertMode :: true
	end if

	for i(str.Len() - 1, col + 1, -1)
		do str[i] :: str[i - 1]
	end for
	if(col < @StrLenMax)
		do str[col] :: ' '
	end if
end func

func Del(col: int, str: []char)
	if(col < @StrLenMax)
		for i(col, str.Len() - 2)
			do str[i] :: str[i + 1]
		end for
		do str[str.Len() - 1] :: 0 $ char
	end if
end func

func BackSpace(col: &int, str: []char)
	if(col > 0)
		do col :- 1
		do @Del(col, str)
	end if
end func

func DeleteSelectedChars(col: &int, str: []char)
	if(col > @ColEnd)
		do col :$ @ColEnd
	end if
	for(1, @ColEnd - col)
		do @Del(col, str)
	end for
end func

func FillSpace(col: int, str: []char)
	while a()
		if(col = 0)
			break a
		elif(str[col - 1] = 0 $ char)
			do str[col - 1] :: ' '
		else
			break a
		end if
		do col :- 1
	end while
end func

func TextLen(str: []char) : int
	for i(0, str.Len() - 1)
		if(str[i] = 0 $ char)
			return i
		end if
	end for
	return @StrLenMax
end func

func InsertChar(col: &int, str: []char, c: &char)
	if(c = 16#7f $ char)
		do @Del(col, str) {Delete}
	elif(col < @StrLenMax)
		do str[col] :: c
		do @FillSpace(col, str)
		do col :+ 1
	end if
	do c :: 0 $ char
	do Dbg@Log(str)
end func

func Main()
	do DrawSub@Initialize()
	do @InitSoundEffects()
	while()
		do @Title()
		do @Game()
	end while
end func

func Title()
	const clickButtonText: []char :: "Click to Start"
	const clickButtonFontWidth: float :: 100.0
	const clickButtonLeft: float :: 100.0
	const clickButtonTop: float :: 400.0
	const clickButtonBottom: float :: clickButtonTop + clickButtonFontWidth * 2.0
	var clickButtonRight: float :: clickButtonLeft + clickButtonText.Len() $ float * clickButtonFontWidth

	var returnFlag:bool :: false
	var mouseX: float
	var mouseY: float

	while()
		do Kuin@Act()
		do Draw@Rect(0.0, 0.0, 1600.0, 900.0, 0.45,0.55,1.0,1.0) {Background}
		do DrawSub@DrawStr("ClickTyping", 50.0, 100.0, 40.0, 1.0, 1.0, 1.0, 1.0)
		do DrawSub@DrawStr("\"" ~ @Hello ~ " " ~ @World ~ "\"", 540.0, 100.0, 60.0, 1.0, 0.0, 1.0, 1.0)
		do Draw@Rect(clickButtonLeft, clickButtonTop, clickButtonRight - clickButtonLeft, clickButtonBottom - clickButtonTop, 1.0,1.0,0.0,0.5)
		do DrawSub@DrawStr(clickButtonText, clickButtonLeft, clickButtonTop, clickButtonFontWidth, 0.0, 1.0, 1.0, 1.0)

		switch(Input@Pad(0, Input@EBtn#A))
		case(1)
			do returnFlag :: true
		case(0)
			if(returnFlag)
				return
			end if
		end switch

		if(Input@Mouse(Input@EMouse#Left) = 1)
			do mouseX :: Input@MouseX()
			do mouseY :: Input@MouseY()
			if(clickButtonLeft < mouseX & mouseX < clickButtonRight & clickButtonTop < mouseY & mouseY < clickButtonBottom)
				do @seStart.Play()
				return
			end if
		end if
	end while
end func

func Game()
	var str: []char :: #[@StrLenMax]char
	var c:char
	var keyboard:SoftwareKeyboard@SoftwareKeyboard :: (#SoftwareKeyboard@SoftwareKeyboard).Init()
	var ending:DrawSub@EndingAnimation :: (#DrawSub@EndingAnimation).Init()
	var col: int :: 0
	var helloFlag:bool :: true
	var worldFlag:bool :: true
	var clearFlag:bool :: true
	do @InputFlag :: true
	do @InsertMode :: true
	var currentFlame: int :: 0
	var currentTimeStr: []char

	var bestScoreFlame: int :: 0
	var savedataBins: []byte8 :: SaveData@Load(@Savefile)
	do bestScoreFlame :: (savedataBins =& null) ?(0, savedataBins $ int)
	var bestScoreTimeStr: []char :: Frame2TimeStr(bestScoreFlame)
	var newRecord:bool
	var mouseX: float
	var mouseY: float

	func Frame2TimeStr(frame: int): []char
		if(frame = 0)
			return "--------"
		else
			return (frame / @FPS).ToStr() ~ "." ~ ((frame%@FPS) * 100 / @FPS).ToStrF("02d") ~ " sec."
		end if
	end func

	while MainLoop()
		do Kuin@Act()
		do Draw@Rect(0.0, 0.0, 1600.0, 900.0, 0.45, 0.55, 1.0, 1.0) {Background}
		do Draw@Rect(0.0, 0.0, 1600.0, DrawSub@Dfh, 0.4, 0.4, 0.4, 1.0) {EditLine}
		do Draw@Rect(@TextLen(str) $ float * DrawSub@Dfw, 0.0, 1600.0, DrawSub@Dfh, 0.2, 0.2, 0.2, 1.0) {EditLine}
		do DrawSub@DrawStr("HI SCORE:", 1200.0, 100.0, 30.0, 1.0, 0.0, 1.0, 1.0)
		do DrawSub@DrawStr(bestScoreTimeStr, 1600.0 - 30.0 * bestScoreTimeStr.Len() $ float, 160.0, 30.0, 1.0, 0.0, 1.0, 1.0)
		do DrawSub@DrawStr("Time:", 1200.0, 300.0, 30.0, 1.0, 1.0, 1.0, 1.0)
		do currentTimeStr :: Frame2TimeStr(currentFlame)
		do DrawSub@DrawStr(currentTimeStr, 1600.0 - 30.0 * currentTimeStr.Len() $ float, 360.0, 30.0, 1.0, 1.0, 1.0, 1.0)
		if(Input@Pad(0, Input@EBtn#C) = 1)
			do @seCancel.Play()
			return
		end if

		if(helloFlag)
			if(StrCmp(str, @Hello))
				do helloFlag :: false
				do @seNext.Play()
				do str :: #[@StrLenMax]char
				do keyboard.SetVels()
				do col :: 0
			end if
		elif(worldFlag)
			if(StrCmp(str, @World))
				do str :: #[@StrLenMax]char
				do worldFlag :: false
				do @seNext.Play()
			end if
		else
			if(clearFlag)
				do bestScoreFlame :: newRecord ?(currentFlame, bestScoreFlame)
				do bestScoreTimeStr :: Frame2TimeStr(bestScoreFlame)
				do SaveData@Save(@Savefile, bestScoreFlame.ToBins())
				do clearFlag :: false
			end if
			if(ending.Animation())
				if(Input@Pad(0, Input@EBtn#A) = 1 | Input@Mouse(Input@EMouse#Left) = 1)
					do @seRestart.Play()
					return
				end if
			end if
			continue MainLoop
		end if

		do currentFlame :+ 1
		do newRecord :: (bestScoreFlame = 0 | currentFlame < bestScoreFlame) ?(true, false)

		if(helloFlag)
			do DrawSub@DrawStr(@Hello, 0.0, 0.0, DrawSub@Dfw, 1.0, 1.0, 1.0, 0.1)
		else
			do DrawSub@DrawStr(@World, 0.0, 0.0, DrawSub@Dfw, 1.0, 1.0, 1.0, 0.1)
		end if
		do keyboard.KeyboardAct(&c)
		do Edit(&col, str, &c)
		do DrawText(str)
		do DrawCursor(col)

		func StrCmp(str1: []char, str2: []char) :bool
			for i(0, str2.Len() - 1)
				if(str1[i] <> str2[i])
					return false
				end if
			end for
			return true
		end func
	end while

	func Edit(col: &int, str: []char, c: &char)
		{Space key}
		var n: int :: Input@Pad(0, Input@EBtn#A)
		if(n > 0)
			const framePerChar: int :: 3
			do c :: (32 + ((n - 1) / framePerChar) % DrawSub@CharNum) $ char
			if(n = 1)
				do @InputFlag :: true
				do @UnShiftStr(&col, str)
			else
				do DrawSub@DrawChar(c, DrawSub@Dfw * col $ float, DrawSub@Dfh * 0.0, DrawSub@Dfw, 1.0,1.0,1.0,1.0)
				if(col < @StrLenMax)
					do str[col] :: ' '
				end if
			end if
		elif(c <> 0 $ char)
			do @UnShiftStr(&col, str)
			if(@InputFlag)
				do @InputFlag :: false
				do @Del(col, str) {Cancel inserting ' '}
			end if
			do @InsertChar(&col, str, &c)
			do @InsertMode :: true
		end if

		{Arrow keys}
		if(Input@Pad(0, Input@EBtn#Left) % @InputSpan = 1) {Left}
			if(col <> 0)
				if(n > 0)
					do str[col] :$ str[col - 1]
				end if
				do col :- 1
			end if
			do @InsertMode :: true
		elif(Input@Pad(0, Input@EBtn#Right) % @InputSpan = 1) {Right}
			if(col <> @StrLenMax - 1)
				if(n > 0)
					do str[col] :$ str[col + 1]
				end if
				do col :+ 1
			end if
			do @InsertMode :: true
		elif(Input@Pad(0, Input@EBtn#B) % @InputSpan = 1) {BackSpace}
			if(@InsertMode)
				do @BackSpace(&col, str)
			else
				do @DeleteSelectedChars(&col, str)
			end if
			do Dbg@Log(str)
			do @InsertMode :: true
		end if

		{ Click (Editor area) }
		var mouseX: float :: Input@MouseX()
		var mouseY: float :: Input@MouseY()
		if(mouseY > 0.0 & mouseY < DrawSub@Dfh)
			var m: int :: Input@Mouse(Input@EMouse#Left)
			if(m = 1)
				do @InsertMode :: true
				do col :: (mouseX / DrawSub@Dfw + 0.4) $ int
				if(col > @StrLenMax - 1)
					do col :: @StrLenMax
				end if
			elif(m <> 0)
				do @ColEnd :: (mouseX / DrawSub@Dfw + 0.4) $ int
				var textLen: int :: @TextLen(str)
				if(col < textLen)
					if(@ColEnd < textLen)
					else
						do @ColEnd :: textLen
					end if
					if(col <> @ColEnd)
						do @InsertMode :: false
					end if
				else
					if(@ColEnd < textLen)
						do col :: textLen
						do @InsertMode :: false
					else
						do col :: @ColEnd
					end if
				end if
			end if
		end if
	end func

	func DrawText(str: []char)
		var i: int :: 0

		foreach c(str)
			var n: int :: c $ int - 32
			if(c = 0 $ char)
				break c
			end if
			do DrawSub@DrawChar(c, DrawSub@Dfw * i $ float, DrawSub@Dfh * 0.0, DrawSub@Dfw, 1.0,1.0,1.0,1.0)
			do i :+ 1
		end foreach
	end func

	func DrawCursor(col: int)
		if(@InsertMode)
			if(Kuin@Cnt() % 50 > 25)
				do Draw@Rect(DrawSub@Dfw * col $ float, 0.0, 5.0, DrawSub@Dfh, 0.0, 1.0, 0.0, 1.0)
			end if
		else
			do Draw@Rect(DrawSub@Dfw * col $ float, 0.0, DrawSub@Dfw * (@ColEnd - col) $ float, DrawSub@Dfh, 0.0, 1.0, 0.0, 0.5)
		end if
	end func
end func
